<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2021-04-24">

<title>Joeyonng - RIPPER</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Joeyonng</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://joeyonng.github.io/joeyonng-notebook/" rel="" target="">
 <span class="menu-text">Notebook</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../Notes/index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Pages</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://joeyonng.github.io/joeyonng-backyard/" rel="" target="">
 <span class="menu-text">Backyard</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Notes/index.html">Research Notes</a></li><li class="breadcrumb-item"><a href="../Notes/RIPPER.html">RIPPER</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../Notes/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Research Notes</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/Birkhoff+.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Birkhoff+</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/CG Decision Rules.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CG Decision Rules</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/Confident Learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Confident Learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/L0 Regularization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">L0 Regularization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/ML Q&amp;A.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Q &amp; A</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/MLIC IMLI.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">MLIC IMLI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/MobileNets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mobile Nets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/Quantization Survey.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantization Survey</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/RIPPER.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">RIPPER</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/SGD Warm Restarts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SGD Warm Restarts</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/SSGD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SSGD</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Notes/Traversing Diagonals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Traversing Diagonals</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#irep-cohen-version" id="toc-irep-cohen-version" class="nav-link" data-scroll-target="#irep-cohen-version">## IREP (Cohen version)</a>
  <ul class="collapse">
  <li><a href="#irep-algorithm" id="toc-irep-algorithm" class="nav-link" data-scroll-target="#irep-algorithm">IREP algorithm</a></li>
  <li><a href="#grow-a-rule" id="toc-grow-a-rule" class="nav-link" data-scroll-target="#grow-a-rule">Grow a Rule</a></li>
  <li><a href="#prune-a-rule" id="toc-prune-a-rule" class="nav-link" data-scroll-target="#prune-a-rule">Prune a Rule</a></li>
  </ul></li>
  <li><a href="#irep-as-an-improved-version-of-irep" id="toc-irep-as-an-improved-version-of-irep" class="nav-link" data-scroll-target="#irep-as-an-improved-version-of-irep">IREP* as an improved version of IREP</a>
  <ul class="collapse">
  <li><a href="#new-rule-value-metric" id="toc-new-rule-value-metric" class="nav-link" data-scroll-target="#new-rule-value-metric">New Rule-Value metric</a></li>
  <li><a href="#new-stopping-condition" id="toc-new-stopping-condition" class="nav-link" data-scroll-target="#new-stopping-condition">New Stopping condition</a></li>
  </ul></li>
  <li><a href="#ripper" id="toc-ripper" class="nav-link" data-scroll-target="#ripper">## RIPPER</a>
  <ul class="collapse">
  <li><a href="#ripper-irep-a-post-processing-optimization" id="toc-ripper-irep-a-post-processing-optimization" class="nav-link" data-scroll-target="#ripper-irep-a-post-processing-optimization">RIPPER = IREP* + a post-processing optimization</a></li>
  <li><a href="#ripper2-and-ripperk" id="toc-ripper2-and-ripperk" class="nav-link" data-scroll-target="#ripper2-and-ripperk">RIPPER2 and RIPPERk</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">RIPPER</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 24, 2021</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>This page contains my reading notes on</p>
<ul>
<li><a href="https://www.semanticscholar.org/paper/Fast-Effective-Rule-Induction-Cohen/6665e03447f989c9bdb3432d93e89b516b9d18a7"><strong>Fast Eective Rule Induction</strong></a></li>
</ul>
<p>Some of the knowledge are also from:</p>
<ul>
<li><a href="https://www.semanticscholar.org/paper/Incremental-Reduced-Error-Pruning-F%C3%BCrnkranz-Widmer/e37790eae6a0ed842c7260df39aab9161c4d1aa1"><strong>Incremental Reduced Error Pruning</strong></a></li>
<li><a href="https://www.semanticscholar.org/paper/MDL-and-Categorical-Theories-(Continued)-Quinlan/cb94e3d981a5e1901793c6bfedd93ce9cc07885d"><strong>MDL and Categorical Theories (Continued)</strong></a></li>
<li><a href="https://towardsdatascience.com/how-to-perform-explainable-machine-learning-classification-without-any-trees-873db4192c68"><strong>A blog post on his RIPPER Python package</strong></a></li>
</ul>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<hr>
<ol type="1">
<li>In this paper, Cohen first implements his own version of <a href="https://www.semanticscholar.org/paper/Incremental-Reduced-Error-Pruning-F%C3%BCrnkranz-Widmer/e37790eae6a0ed842c7260df39aab9161c4d1aa1"><strong>IREP</strong></a> (Incremental Reduced Error Pruning) with some minor differences and has support multi-label problems and missing attributes.</li>
<li>Then he proposes several major changes to IREP and names the improved version <strong>IREP*</strong>.</li>
<li>Finally, based on IREP*, he proposes a new rule mining algorithm called <strong>RIPPER</strong> (Repeated Incremental Pruning to Produce Error Reduction).</li>
</ol>
</section>
<section id="irep-cohen-version" class="level2">
<h2 class="anchored" data-anchor-id="irep-cohen-version">## IREP (Cohen version)</h2>
<section id="irep-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="irep-algorithm">IREP algorithm</h3>
<p>The characteristics of IREP have two fold: 1. <strong>Separate and conquer</strong>: the covered instances in the training set are removed after a rule is found; thus in the next iteration, a new rule will be learned on the training instances that have not been covered by the previously found rules. 1. <strong>Integration of pre-pruning and post-pruning</strong>: 1. Pre-pruning: some training examples are deliberately ignored to in the training process (early stopping condition). 1. Post-pruning: first the model is trained to fit the training set perfectly and then some parts of the model are deleted after the training (branch cutting).</p>
<blockquote class="blockquote">
<p><strong>Function</strong>: <em>IREP</em>.<br>
<strong>Input</strong>: the training set <span class="math inline">\mathcal{D}</span> with binary labels and all possible features <span class="math inline">\mathcal{F}</span>.<br>
<strong>Output</strong>: the learned rule set <span class="math inline">\mathcal{R}</span>. 1. Initialize an empty rule set <span class="math inline">\mathcal{R}</span>. 1. While there are still positive instances in <span class="math inline">\mathcal{D}</span>: 1. Randomly choose 2/3 from <span class="math inline">\mathcal{D}</span> as the growing set <span class="math inline">\mathcal{G}</span> and the rest 1/3 becomes the pruning set <span class="math inline">\mathcal{P}</span>. 1. <span class="math inline">R</span> = <em>GrowRule</em>(<span class="math inline">\mathcal{G}</span>) 1. <span class="math inline">R</span> = <em>PruneRule</em>(<span class="math inline">\mathcal{P}</span>, <span class="math inline">R</span>) 1. If the accuracy of <span class="math inline">R &lt; 0.5</span> on <span class="math inline">\mathcal{P}</span>: break 1. Add <span class="math inline">R</span> to <span class="math inline">\mathcal{R}</span>. 1. Remove instances that are covered by <span class="math inline">R</span> from <span class="math inline">\mathcal{D}</span>. 1. Return <span class="math inline">\mathcal{R}</span></p>
</blockquote>
<p>The minor differences between the Cohen’s implementation of IREP and the original version are: 1. stopping condition. The original IREP stopped when the accuracy of the learned rule is less than the accuracy of the empty rule instead of 50%. 1. PruneRule algorithm, which is to be detailed later.</p>
</section>
<section id="grow-a-rule" class="level3">
<h3 class="anchored" data-anchor-id="grow-a-rule">Grow a Rule</h3>
<p>In each iteration, the feature <span class="math inline">f</span> with value <span class="math inline">v</span> that has the <strong>maximum FOIL score</strong> is selected to the rule and the iterations terminate when <strong>the rule doesn’t cover any negative instances</strong> in the growing set.</p>
<blockquote class="blockquote">
<p><strong>Function</strong>: <em>GrowRule</em>.<br>
<strong>Input</strong>: the growing set <span class="math inline">\mathcal{G}</span> with binary labels and all possible features <span class="math inline">\mathcal{F}</span>.<br>
<strong>Output</strong>: the unpruned rule <span class="math inline">R</span>. 1. Initialize an empty rule <span class="math inline">R</span>. 1. Until all instances in <span class="math inline">\mathcal{G}</span> that satisfy <span class="math inline">R</span> are positive (accuracy of <span class="math inline">R</span> is 1 in <span class="math inline">\mathcal{G}</span>) or there is no feature to add: 1. For every feature <span class="math inline">f \in \mathcal{F}</span> not in <span class="math inline">R</span> and every possible value <span class="math inline">v \in \mathcal{V}(f)</span>: 1. Create a temp rule <span class="math inline">R_{t}</span> by copying current <span class="math inline">R</span>. 1. Add <span class="math inline">(f, v)</span> to <span class="math inline">R_{t}</span>. 1. Calculate FOIL’s information gain of <span class="math inline">R_{t}</span>: <span class="math inline">\mathrm{Foil}(R, R_{t})</span> based on <span class="math inline">\mathcal{G}</span>. 1. Get the <span class="math inline">R_{t}^{max}</span> with the max value of <span class="math inline">\mathrm{Foil}(R_{t})</span>. 1. <span class="math inline">R=R_{t}^{max}</span>. 1. Return <span class="math inline">R</span>.</p>
</blockquote>
<p><strong>[Support for categorical and continuous features]</strong>: the definition of <span class="math inline">\mathcal{V}(f)</span> for different feature <span class="math inline">f</span> is different for categorical and numerical features. 1. For a categorical feature <span class="math inline">f_{c}</span>, <span class="math inline">\mathcal{V}(f)</span> is the collection of all possible values that <span class="math inline">f_{c}</span> can take. 1. For a numerical feature <span class="math inline">f_{n}</span>, <span class="math inline">\mathcal{V}(f)</span> is the Cartesian product of <span class="math inline">\{\leq, \geq\}</span> and all values of <span class="math inline">f</span> that appear in the training set. For example, if all values that appear in the training set for feature age is <span class="math inline">\{10, 20, 30\}</span>, then <span class="math inline">\mathcal{V}(\text{age})</span> is <span class="math inline">\{\leq 10, \geq 10, \leq 20, \geq 20, \leq 30, \geq 30\}</span></p>
<p><strong>[FOIL’s information gain]</strong>: it gives how much information entropy is reduced from <span class="math inline">R_{old}</span> to <span class="math inline">R_{new}</span>.</p>
<p><span class="math display"> \operatorname{Foil}(R_{old}, R_{new}) = P(R_{new}) \left( \log_{2} \left( \frac{P(R_{new})}{P(R_{new}) + N(R_{new})} \right) - \log_{2} \left( \frac{P(R_{old})}{P(R_{old}) + N(R_{old})} \right) \right) </span></p>
<p>where <span class="math inline">P(R)</span> (<span class="math inline">N(R)</span>) is the number of positive (negative) instances covered by <span class="math inline">R</span>.</p>
</section>
<section id="prune-a-rule" class="level3">
<h3 class="anchored" data-anchor-id="prune-a-rule">Prune a Rule</h3>
<p>PruneRule considers deleting <strong>any final sequence of conditions in the order they are grown</strong> from the rule and chooses the deletion that <strong>maximizes the Rule-Value metric</strong> on the pruning set.</p>
<blockquote class="blockquote">
<p><strong>Function</strong>: <em>PruneRule</em>.<br>
<strong>Input</strong>: the pruning set <span class="math inline">\mathcal{P}</span> and the unpruned rule <span class="math inline">R</span>.<br>
<strong>Output</strong>: the pruned rule <span class="math inline">R_{p}</span>. 1. Initialize <span class="math inline">R_{p} = R</span>. 1. For all <span class="math inline">(f, v)_{i} \in R</span> starting from the last added one to the first one: 1. Removing <span class="math inline">(f, v)_{i}</span> from <span class="math inline">R</span>. 1. If <span class="math inline">\operatorname{Value}(R) \geq \operatorname{Value}(R_{p})</span>: then <span class="math inline">R_{p} = R</span>. 1. Return <span class="math inline">R_{p}</span></p>
</blockquote>
<p>The original implementation of IREP only considers the “deletions of a single final condition”.</p>
<p><strong>[IREP Rule-Value metric]</strong>:</p>
<p><span class="math display"> \operatorname{Value}(R) = \frac{P(R) + (N - N(R))}{P + N} </span></p>
<p>where <span class="math inline">P</span> (<span class="math inline">N</span>) is the total number of positive (negative) instances and <span class="math inline">P(R)</span> (<span class="math inline">N(R)</span>) is the number of positive (negative) instances covered by <span class="math inline">R</span>.</p>
</section>
</section>
<section id="irep-as-an-improved-version-of-irep" class="level2">
<h2 class="anchored" data-anchor-id="irep-as-an-improved-version-of-irep">IREP* as an improved version of IREP</h2>
<hr>
<p>The support for multi-class and missing value allows IREP to be applied on a wide range of benchmarks and Cohen further improves on his implementation of IREP on the stopping condition and pruning metric.</p>
<section id="new-rule-value-metric" class="level3">
<h3 class="anchored" data-anchor-id="new-rule-value-metric">New Rule-Value metric</h3>
<p>The IREP Rule-Value metric sometimes is highly unintuitive. Assuming <span class="math inline">P</span> and <span class="math inline">N</span> are fixed to be 3000, the IREP Rule-Value metric prefers <span class="math inline">R_{1}</span> over <span class="math inline">R_{2}</span> in the following example, but <span class="math inline">R_{2}</span> is obviously more predictive. - <span class="math inline">R_{1}</span>: <span class="math inline">P(R_{1}) = 2000</span>, <span class="math inline">N(R_{1}) = 1000</span>, <span class="math inline">\operatorname{Value}(R) = \frac{4000}{6000}</span> - <span class="math inline">R_{2}</span>: <span class="math inline">P(R_{2}) = 1000</span>, <span class="math inline">N(R_{2}) = 1</span>, <span class="math inline">\operatorname{Value}(R) = \frac{3999}{6000}</span></p>
<p>Cohen’s solution doesn’t have the issue mentioned above.</p>
<p><strong>[IREP* Rule-Value metric]</strong>:</p>
<p><span class="math display"> \operatorname{Value}(R) = \frac{P(R) - N(R)}{P(R) + N(R)} </span></p>
<p>where <span class="math inline">P(R)</span> is the number of positive instances covered by <span class="math inline">R</span> and <span class="math inline">N(R)</span> is the number of negative instances covered by <span class="math inline">R</span></p>
</section>
<section id="new-stopping-condition" class="level3">
<h3 class="anchored" data-anchor-id="new-stopping-condition">New Stopping condition</h3>
<p>The IREP stops adding rules when the current learned rule has a bad (&lt; 50%) accuracy on the pruning set. This estimate often makes the algorithm stop too early especially if the current learned rule has very low coverage (the algorithm will stop if, for example, the rule only covers 2 instances and 1 instance has negative label).</p>
<p>IREP* defines the stopping condition based on the total <strong>description length</strong> value of the currently learned rule set on the pruning set.</p>
<blockquote class="blockquote">
<ol type="1">
<li>Calculate the total description length of <span class="math inline">\mathcal{R}</span>: <span class="math inline">\operatorname{MDL}(\mathcal{R})</span>.</li>
<li>If <span class="math inline">\operatorname{MDL}(\mathcal{R}) &gt; \operatorname{MDL}_{min} + d</span>: break</li>
<li>If <span class="math inline">\operatorname{MDL}(\mathcal{R}) &lt; \operatorname{MDL}_{min}</span>: <span class="math inline">\operatorname{MDL}_{min} = \operatorname{MDL}(\mathcal{R})</span></li>
</ol>
</blockquote>
<p>where <span class="math inline">\operatorname{MDL}(\mathcal{R})</span> is the total Description Length of the rule set <span class="math inline">\mathcal{R}</span> and <span class="math inline">d</span> is a hyperparameter with the default value of 64 in the paper’s experiment.</p>
<p><strong>[MDL Principle (Minimum Description Length Principle)]</strong>: From the Machine Learning perspective, each model derived from the dataset can be characterized by a <strong>description length</strong>, which is defined as the number of bits required to encode the model and the data from which it was learned. MDL Principle states that the model with the minimum description length is generally preferred to avoid over-fitting.</p>
<p>Description length consists of model description length (theory cost) and exceptions description length (exceptions cost). - Model description length measures the complexity of the model. Higher model description length means that the model is more complex and thus more prone to over-fitting. - Exceptions description length measures the degree to which the model incorrectly fit to the data. The large the exceptions description length, the more error-prone the model is.</p>
<p>For RIPPER, the description length of a rule set is defined as the sum of the model description length of each rule plus the exceptions description length of the whole rule set:</p>
<p><span class="math display"> \operatorname{MDL}(\mathcal{R}) = \sum_{R_{i} \in \mathcal{R}} \operatorname{MDL}_{M}(R_{i}) + \operatorname{MDL}_{E}(\mathcal{R}) </span></p>
<p>Model description length of each rule calculates how many bits are needed to encode a rule:</p>
<p><span class="math display"> \operatorname{MDL}_{M}(R) = 0.5(k\log_{2}\frac{1}{p} + (n - k) \log_2\frac{1}{1 - p} + \lVert k \rVert) </span></p>
<p>where <span class="math inline">k</span> is the number of features in the rule, <span class="math inline">n</span> is the number of all features, and <span class="math inline">p = \frac{k}{n}</span>. <span class="math inline">\lVert k \rVert = \log_{2}(k)</span> is the number of bits required to encode the number <span class="math inline">k</span>. The <span class="math inline">0.5</span> factor is to “account for possible redundancies”.</p>
<p>Exceptions description length evaluates the errors of the rule set on a given dataset:</p>
<p><span class="math display"> \operatorname{MDL}_{E}(\mathcal{R}) = \log_{2}{P(\mathcal{R}) \choose \mathit{FP}(\mathcal{R})} + \log_{2}{N(\mathcal{R}) \choose \mathit{FN}(\mathcal{R})}</span></p>
<p>where <span class="math inline">P(\mathcal{R})</span> (<span class="math inline">N(\mathcal{R})</span>) is the number of positive (negative) instances covered by the rule set <span class="math inline">\mathcal{R}</span> and <span class="math inline">\mathit{FP}(\mathcal{R})</span> (<span class="math inline">\mathit{FN}(\mathcal{R})</span>) is the number of false positives (false negatives) covered by the rule set <span class="math inline">\mathcal{R}</span>.</p>
</section>
</section>
<section id="ripper" class="level2">
<h2 class="anchored" data-anchor-id="ripper">## RIPPER</h2>
<p>TODO: Many of the implementation details are from this public <a href="https://github.com/imoscovitz/wittgenstein">Github implementation</a>, since the original paper doesn’t elaborate on how exactly they are implemented.</p>
<section id="ripper-irep-a-post-processing-optimization" class="level3">
<h3 class="anchored" data-anchor-id="ripper-irep-a-post-processing-optimization">RIPPER = IREP* + a post-processing optimization</h3>
<p>RIPPER further improves on IREP* by post-pruning the rules generated by IREP*.</p>
<blockquote class="blockquote">
<p><strong>Function</strong>: <em>RIPPER</em>.<br>
<strong>Input</strong>: a training set <span class="math inline">\mathcal{D}</span>.<br>
<strong>Output</strong>: a optimized rule set <span class="math inline">\mathcal{R}_{o}</span>. 1. Run IREP* on <span class="math inline">\mathcal{D}</span> to get <span class="math inline">\mathcal{R}</span>. 1. <span class="math inline">\mathcal{R}_{o}</span> = <em>Optimize</em>(<span class="math inline">\mathcal{D}</span>, <span class="math inline">\mathcal{R}</span>). Note that <span class="math inline">\mathcal{D}</span> here is a copy of the original training set (no removal from IREP<em>). 1. While there are still positive instances in <span class="math inline">\mathcal{D}</span>: 1. <span class="math inline">R</span> = </em>GrowRule*(<span class="math inline">\mathcal{D}</span>). 1. Remove instances that are covered by <span class="math inline">R_{i}^{best}</span> from <span class="math inline">\mathcal{D}</span>. 1. Add <span class="math inline">R</span> to <span class="math inline">\mathcal{R}_{o}</span>. 1. Return <span class="math inline">\mathcal{R}_{o}</span>.</p>
</blockquote>
<p>The <em>optimize</em> procedure proposes 2 more versions of the rule for each rule learned from IREP* and select the best version using MDL metric to add to the final rule set.</p>
<blockquote class="blockquote">
<p><strong>Function</strong>: <em>Optimize</em>.<br>
<strong>Input</strong>: a training set <span class="math inline">\mathcal{D}</span> and a rule set <span class="math inline">\mathcal{R}</span>.<br>
<strong>Output</strong>: a optimized rule set <span class="math inline">\mathcal{R}_{o}</span>. 1. Initialize an empty rule set <span class="math inline">\mathcal{R}_{o}</span>. 1. For each <span class="math inline">R_{i} \in \mathcal{R}</span> in the order <span class="math inline">R_{i}</span> is learned in <span class="math inline">\mathcal{R}</span>: 1. Randomly choose 2/3 from <span class="math inline">\mathcal{D}</span> as the growing set <span class="math inline">\mathcal{G}</span> and the rest 1/3 becomes the pruning set <span class="math inline">\mathcal{P}</span>. 1. Grow the <strong>replacement</strong> rule from <strong>scratch</strong> using FOIL’s information gain: <span class="math inline">\hat{R}_{i}</span> = <em>GrowRule</em>(<span class="math inline">\mathcal{G}</span>). 1. Form a new rule set by replacing <span class="math inline">R_{i}</span> in <span class="math inline">\mathcal{R}</span> with <span class="math inline">\hat{R}_{i}</span>: <span class="math inline">\mathcal{\hat{R}} = \{R_{1}, \dots, \hat{R}_{i}, \dots, R_{n}</span>}. 1. Prune the replacement rule: <span class="math inline">\hat{R}_{i}</span> = <em>PruneRule</em>(<span class="math inline">\mathcal{P}</span>, <span class="math inline">\hat{R}_{i}</span>), but using <strong>accuracy of the rule set <span class="math inline">\mathcal{\hat{R}}</span></strong> instead of Rule-Value metric as the maximizing objective. 1. Update the <span class="math inline">\hat{R}_{i}</span> in <span class="math inline">\hat{\mathcal{R}}</span> with the pruned version. 1. Grow the <strong>revision</strong> rule from the <strong>current rule</strong> <span class="math inline">R_{i}</span> using FOIL’s information gain: <span class="math inline">\bar{R}_{i}</span> = <em>GrowRule</em>(<span class="math inline">\mathcal{G}</span>). 1. Form a new rule set by replacing <span class="math inline">R_{i}</span> in <span class="math inline">\mathcal{R}</span> with <span class="math inline">\bar{R}_{i}</span>: <span class="math inline">\mathcal{\bar{R}} = \{R_{1}, \dots, \bar{R}_{i}, \dots, R_{n}</span>}. 1. Prune the revision rule: <span class="math inline">\bar{R}_{i}</span> = <em>PruneRule</em>(<span class="math inline">\mathcal{P}</span>, <span class="math inline">\bar{R}_{i}</span>), but using <strong>accuracy of the rule set <span class="math inline">\mathcal{\bar{R}}</span></strong> instead of Rule-Value metric as the maximizing objective. 1. Update the <span class="math inline">\bar{R}_{i}</span> in <span class="math inline">\bar{\mathcal{R}}</span> with the pruned version. 1. The best rule from the 3 versions is the one whose corresponding rule set has the smallest <strong>minimum total description length</strong>: <span class="math inline">R_{i}^{best} = \arg \min_{R \in \{R_{i}, \hat{R}_{i}, \bar{R}_{i}\}} \operatorname{MTDL} (\{R_{1}, \dots, R, \dots, R_{n}\})</span>. 1. Add <span class="math inline">R_{i}^{best}</span> to <span class="math inline">\mathcal{R}_{o}</span>. 1. Remove instances that are covered by <span class="math inline">R_{i}^{best}</span> from <span class="math inline">\mathcal{D}</span>. 1. If there is no positive instances in <span class="math inline">\mathcal{D}</span>: break. 1. Return <span class="math inline">\mathcal{R}_{o}</span>.</p>
</blockquote>
<p><strong>[Minimum total description length]</strong>: Given a rule set, the minimum total description length is the description length of the rule set after deleting the rules that increase the total description length of the rule set.</p>
</section>
<section id="ripper2-and-ripperk" class="level3">
<h3 class="anchored" data-anchor-id="ripper2-and-ripperk">RIPPER2 and RIPPERk</h3>
<p>RIPPER2 is just running <em>Optimize</em> again on the output of RIPPER, while RIPPERk is to run RIPPER k times.</p>
<blockquote class="blockquote">
<p><strong>Function</strong>: <em>RIPPER2</em>.<br>
<strong>Input</strong>: a training set <span class="math inline">\mathcal{D}</span>.<br>
<strong>Output</strong>: a optimized rule set <span class="math inline">\mathcal{R}_{o}</span>. 1. Run <em>RIPPER</em> on <span class="math inline">\mathcal{D}</span> to get <span class="math inline">\mathcal{R}</span>. 1. <span class="math inline">\mathcal{R}_{o}</span> = <em>Optimize</em>(<span class="math inline">\mathcal{D}</span>, <span class="math inline">\mathcal{R}</span>). Note that <span class="math inline">\mathcal{D}</span> here is a copy of the original training set (no removal from IREP<em>). 1. While there are still positive instances in <span class="math inline">\mathcal{D}</span>: 1. <span class="math inline">R</span> = </em>GrowRule*(<span class="math inline">\mathcal{D}</span>). 1. Remove instances that are covered by <span class="math inline">R_{i}^{best}</span> from <span class="math inline">\mathcal{D}</span>. 1. Add <span class="math inline">R</span> to <span class="math inline">\mathcal{R}_{o}</span>. 1. Return <span class="math inline">\mathcal{R}_{o}</span>.</p>
</blockquote>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>